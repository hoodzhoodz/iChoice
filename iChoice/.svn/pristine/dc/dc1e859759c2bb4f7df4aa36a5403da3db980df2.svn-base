package com.choicemmed.ichoice.healthreport.custom;

import android.animation.ValueAnimator;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.RectF;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;

import com.choicemmed.ichoice.R;
import com.choicemmed.ichoice.healthreport.utils.DpOrPxUtils;

import java.text.BreakIterator;
import java.util.jar.Attributes;

public class OxCircle extends View {
    private Paint bigCirclePaint;
    private Paint smallCirclePaint;

    private float barWidth = 12;//圆弧进度条宽度
    private int defaultSize;//自定义View默认的宽高
    private RectF mRectF;//绘制圆弧的矩形区域
    int bigStart = 60;
    int bigEnd = 280;
    int smallStart = 90;
    int smallEnd = 140;
    float small_startAngle;
    float small_sweepAngle;

    private ValueAnimator animator;
    Bitmap bitmap;
    private float targetDegree = 0;
    private Context mContext;
    private int globeWidth = 18;

   public OxCircle(Context context){
       super(context);
   }
   public OxCircle(Context context,@Nullable AttributeSet attributeSet){
       super(context,attributeSet);
       init(context,attributeSet);
   }
   public  OxCircle(Context context, @Nullable AttributeSet attributeSet, int defStyleAttr){
       super(context,attributeSet,defStyleAttr);
   }

   private void init(Context context,AttributeSet attributeSet){

       mContext = context;

       bigCirclePaint = new Paint();
       smallCirclePaint = new Paint();
       bigCirclePaint.setAntiAlias(true);
       bigCirclePaint.setStyle(Paint.Style.STROKE);
       bigCirclePaint.setStrokeWidth(barWidth);
       bigCirclePaint.setStrokeCap(Paint.Cap.ROUND);
       bigCirclePaint.setColor(Color.rgb(192,192,192));
       smallCirclePaint.setAntiAlias(true);
       smallCirclePaint.setStyle(Paint.Style.STROKE);
       smallCirclePaint.setStrokeWidth(barWidth);
       smallCirclePaint.setStrokeCap(Paint.Cap.ROUND);
       smallCirclePaint.setColor(Color.rgb(52,213,207));

       mRectF = new RectF();
       defaultSize = DpOrPxUtils.dip2px(context,150);
       animator(180);
   }

   private void animator(float value){
       targetDegree = value;
       Bitmap globeBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ox_circle);
       Matrix matrix = new Matrix();
       int newSize = DpOrPxUtils.dip2px(mContext,globeWidth);
       int globeSize = globeBitmap.getWidth();
       float scale = newSize/globeSize;
       matrix.postScale(scale,scale);

       bitmap = Bitmap.createBitmap(globeBitmap,0,0,globeBitmap.getWidth(),globeBitmap.getHeight());
       animator = ValueAnimator.ofFloat(135,value);
       animator.setDuration(1000);
       animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
           @Override
           public void onAnimationUpdate(ValueAnimator animation) {
               targetDegree = (float)animation.getAnimatedValue();
               invalidate();
           }
       });
    }
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        int height = measureSize(defaultSize, heightMeasureSpec);
        int width = measureSize(defaultSize, widthMeasureSpec);
        int min = Math.min(width, height);// 获取View最短边的长度
        setMeasuredDimension(min, min);// 强制改View为以最短边为长度的正方形

        if (min >= barWidth * 2) {
            mRectF.set(barWidth / 2.0f, barWidth / 2.0f, min - barWidth / 2.0f, min - barWidth / 2.0f);
        }
    }

    private int measureSize(int defaultSize,int measureSpec) {
        int result = defaultSize;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if (specMode == MeasureSpec.EXACTLY) {
            result = specSize;
        } else if (specMode == MeasureSpec.AT_MOST) {
            result = Math.min(result, specSize);
        }
        return result;
    }


    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        RectF newRect = new RectF(mRectF.left+15,mRectF.top+15,mRectF.right-15,mRectF.bottom-15);
        canvas.drawArc(newRect,135,270,false,bigCirclePaint);
        compterData();
        canvas.drawArc(newRect,small_startAngle,small_sweepAngle,false,smallCirclePaint);

        float newSize = DpOrPxUtils.dip2px(mContext,bitmap.getWidth());
        float width = mRectF.right-mRectF.left;
        float radius = (width-bitmap.getWidth() )/2.0f;
        float xValue = (float) (mRectF.left+width/2.0f+radius*Math.cos(targetDegree*Math.PI/180)-bitmap.getWidth()/2.0f);
        float yValue = (float) (mRectF.top+width/2.0f+radius*Math.sin(targetDegree*Math.PI/180)-bitmap.getWidth()/2.0f);
        canvas.drawBitmap(bitmap,xValue,yValue,null);
    }

    private void compterData() {
        float BigMax = bigEnd - bigStart;
        float one =  270/BigMax;
        small_startAngle = 135 + one * (smallStart - bigStart);
        small_sweepAngle =(smallEnd - smallStart) * one;
        Log.d("angle","("+smallStart+","+smallEnd+")"+ small_startAngle+"|"+small_sweepAngle);
    }

    public void setBig(int bigStart,int bigEnd) {
        this.bigStart = bigStart;
        this.bigEnd = bigEnd;
    }

    public void setSmall(int smallStart,int smallEnd) {
        this.smallStart = smallStart;
        this.smallEnd = smallEnd;
    }

}
